import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { useWebSocket } from '../hooks/useWebSocket';
import type { Notification, NotificationSettings } from '../types/notification';

interface NotificationContextType {
  notifications: Notification[];
  unreadCount: number;
  settings: NotificationSettings;
  isLoading: boolean;
  connectionStatus: string;
  
  // 액션 함수들
  markAsRead: (id: string) => Promise<void>;
  markAllAsRead: () => Promise<void>;
  updateSettings: (settings: NotificationSettings) => Promise<void>;
  refreshNotifications: () => Promise<void>;
}

const NotificationContext = createContext<NotificationContextType | undefined>(undefined);

interface NotificationProviderProps {
  children: ReactNode;
}

export const NotificationProvider: React.FC<NotificationProviderProps> = ({ children }) => {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [unreadCount, setUnreadCount] = useState(0);
  const [settings, setSettings] = useState<NotificationSettings>({
    enabled: true,
    soundEnabled: true,
    browserNotification: true,
  });
  const [isLoading, setIsLoading] = useState(true);

  const { connectionStatus, on, off } = useWebSocket();

  // API 호출 함수들
  const fetchNotifications = async (): Promise<Notification[]> => {
    const response = await fetch('/api/notifications');
    if (!response.ok) throw new Error('알림 목록을 불러오지 못했습니다');
    return response.json();
  };

  const fetchSettings = async (): Promise<NotificationSettings> => {
    const response = await fetch('/api/settings');
    if (!response.ok) throw new Error('설정을 불러오지 못했습니다');
    return response.json();
  };

  const markAsRead = async (id: string): Promise<void> => {
    const response = await fetch(`/api/notifications/${id}/read`, {
      method: 'PUT',
    });
    if (!response.ok) throw new Error('알림을 읽음 처리하지 못했습니다');

    // 상태 업데이트
    setNotifications(prev =>
      prev.map(notification =>
        notification.id === id ? { ...notification, isRead: true } : notification
      )
    );
    setUnreadCount(prev => Math.max(0, prev - 1));
  };

  const markAllAsRead = async (): Promise<void> => {
    const unreadNotifications = notifications.filter(n => !n.isRead);
    
    // 모든 읽지 않은 알림을 병렬로 처리
    await Promise.all(
      unreadNotifications.map(notification => markAsRead(notification.id))
    );
  };

  const updateSettings = async (newSettings: NotificationSettings): Promise<void> => {
    const response = await fetch('/api/settings', {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(newSettings),
    });
    
    if (!response.ok) throw new Error('설정을 저장하지 못했습니다');
    setSettings(newSettings);
  };

  const refreshNotifications = async (): Promise<void> => {
    try {
      setIsLoading(true);
      const [notificationData, settingsData] = await Promise.all([
        fetchNotifications(),
        fetchSettings(),
      ]);
      
      setNotifications(notificationData);
      setSettings(settingsData);
      setUnreadCount(notificationData.filter(n => !n.isRead).length);
    } catch (error) {
      console.error('데이터 새로고침 실패:', error);
    } finally {
      setIsLoading(false);
    }
  };

  // WebSocket 이벤트 핸들러
  useEffect(() => {
    // 새 알림 수신
    const handleNewNotification = (notification: Notification) => {
      setNotifications(prev => [notification, ...prev]);
      setUnreadCount(prev => prev + 1);

      // 브라우저 알림
      if (settings.browserNotification && Notification.permission === 'granted') {
        new Notification(notification.title, {
          body: notification.message,
          icon: '/notification-icon.png',
        });
      }
    };

    // 알림 읽음 처리
    const handleNotificationRead = (notificationId: string) => {
      setNotifications(prev =>
        prev.map(n =>
          n.id === notificationId ? { ...n, isRead: true } : n
        )
      );
      setUnreadCount(prev => Math.max(0, prev - 1));
    };

    // 읽지 않은 수 업데이트
    const handleCountUpdated = (count: number) => {
      setUnreadCount(count);
    };

    // 이벤트 리스너 등록
    on('notification:new', handleNewNotification);
    on('notification:read', handleNotificationRead);
    on('notifications:count_updated', handleCountUpdated);

    // 컴포넌트 언마운트 시 리스너 제거
    return () => {
      off('notification:new', handleNewNotification);
      off('notification:read', handleNotificationRead);
      off('notifications:count_updated', handleCountUpdated);
    };
  }, [on, off, settings.browserNotification]);

  // 초기 데이터 로딩
  useEffect(() => {
    refreshNotifications();

    // 브라우저 알림 권한 요청
    if (settings.browserNotification && Notification.permission === 'default') {
      Notification.requestPermission();
    }
  }, []);

  const value: NotificationContextType = {
    notifications,
    unreadCount,
    settings,
    isLoading,
    connectionStatus,
    markAsRead,
    markAllAsRead,
    updateSettings,
    refreshNotifications,
  };

  return (
    <NotificationContext.Provider value={value}>
      {children}
    </NotificationContext.Provider>
  );
};

// Context 사용을 위한 커스텀 훅
export const useNotification = (): NotificationContextType => {
  const context = useContext(NotificationContext);
  if (!context) {
    throw new Error('useNotification은 NotificationProvider 내에서 사용해야 합니다');
  }
  return context;
};